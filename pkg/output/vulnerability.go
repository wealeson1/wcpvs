package output

import (
	"fmt"
	"strings"
)

// VulnerabilityReport æ¼æ´žæŠ¥å‘Šç»“æž„
type VulnerabilityReport struct {
	Severity     string   // "CRITICAL", "HIGH", "MEDIUM", "LOW"
	Type         string   // "HCP", "CPDoS-HHO", "ParameterCP", etc.
	Target       string   // Target URL
	CDN          string   // CDN type (e.g., "Cloudflare", "Nginx")
	CacheKeys    []string // Cache keys involved (e.g., ["Host", "Accept-Encoding"])
	AttackVector string   // Brief description of attack vector
	Request      string   // Full HTTP request (formatted)
	Response     string   // Full HTTP response (formatted)
	Impact       string   // Impact description
	Persistent   bool     // Whether vulnerability is persistent
	Remediation  []string // List of remediation steps
}

// Print è¾“å‡ºç¾ŽåŒ–çš„æ¼æ´žæŠ¥å‘Š
func (v *VulnerabilityReport) Print() {
	borderLength := 70

	// é¡¶éƒ¨è¾¹æ¡†
	fmt.Println("\n" + TopBorder(borderLength))

	// æ ‡é¢˜è¡Œ
	icon := v.getSeverityIcon()
	title := fmt.Sprintf(" %s %s: %s", icon, v.Severity, v.Type)
	fmt.Println(SideBorder + title)

	// åˆ†éš”çº¿
	fmt.Println(MiddleBorder(borderLength))

	// ç›®æ ‡ä¿¡æ¯
	fmt.Println(SideBorder + fmt.Sprintf(" ðŸŽ¯ Target: %s", v.Target))
	fmt.Println(SideBorder)

	// ç¼“å­˜ä¿¡æ¯
	if v.CDN != "" {
		fmt.Println(SideBorder + fmt.Sprintf(" ðŸ”‘ Cache: %s", v.CDN))
	}
	if len(v.CacheKeys) > 0 {
		fmt.Println(SideBorder + fmt.Sprintf("    Keys: %s", strings.Join(v.CacheKeys, ", ")))
	}
	fmt.Println(SideBorder)

	// æ”»å‡»ç»†èŠ‚
	fmt.Println(SideBorder + " âš”ï¸  Attack:")
	fmt.Println(SideBorder + fmt.Sprintf("    Vector: %s", v.AttackVector))
	if v.Persistent {
		fmt.Println(SideBorder + "    Persistent: âœ“ YES (verified)")
	} else {
		fmt.Println(SideBorder + "    Persistent: âœ— NO")
	}
	fmt.Println(SideBorder)

	// è¯·æ±‚åŒ…
	if v.Request != "" {
		fmt.Println(SideBorder + " ðŸ“¦ Request:")
		v.printBox(v.Request)
		fmt.Println(SideBorder)
	}

	// å“åº”åŒ…
	if v.Response != "" {
		fmt.Println(SideBorder + " ðŸ“¥ Response:")
		v.printBox(v.Response)
		fmt.Println(SideBorder)
	}

	// å½±å“æè¿°
	if v.Impact != "" {
		fmt.Println(SideBorder + fmt.Sprintf(" ðŸ’¥ Impact: %s", v.Impact))
		fmt.Println(SideBorder)
	}

	// ä¿®å¤å»ºè®®
	if len(v.Remediation) > 0 {
		fmt.Println(SideBorder + " ðŸ›¡ï¸  Remediation:")
		for i, r := range v.Remediation {
			fmt.Println(SideBorder + fmt.Sprintf("   %d. %s", i+1, r))
		}
	}

	// åº•éƒ¨è¾¹æ¡†
	fmt.Println(BottomBorder(borderLength))
	fmt.Println()
}

// printBox åœ¨è¾¹æ¡†å†…æ‰“å°æ–‡æœ¬æ¡†
func (v *VulnerabilityReport) printBox(text string) {
	lines := strings.Split(text, "\n")
	
	// æ‰“å°é¡¶éƒ¨è¾¹æ¡†
	fmt.Println(SideBorder + "   â”Œ" + strings.Repeat("â”€", 60) + "â”")
	
	// æ‰“å°å†…å®¹
	for _, line := range lines {
		if line != "" {
			// æˆªæ–­è¿‡é•¿çš„è¡Œï¼ˆæŒ‰å­—ç¬¦è€Œéžå­—èŠ‚ï¼Œé¿å…UTF-8ä¹±ç ï¼‰
			runes := []rune(line)
			if len(runes) > 58 {
				line = string(runes[:55]) + "..."
			}
			fmt.Println(SideBorder + "   â”‚ " + line)
		}
	}
	
	// æ‰“å°åº•éƒ¨è¾¹æ¡†
	fmt.Println(SideBorder + "   â””" + strings.Repeat("â”€", 60) + "â”˜")
}

// getSeverityIcon æ ¹æ®ä¸¥é‡ç¨‹åº¦è¿”å›žå›¾æ ‡
func (v *VulnerabilityReport) getSeverityIcon() string {
	switch v.Severity {
	case "CRITICAL":
		return "ðŸ”´"
	case "HIGH":
		return "ðŸŸ "
	case "MEDIUM":
		return "ðŸŸ¡"
	case "LOW":
		return "ðŸŸ¢"
	default:
		return "âšª"
	}
}

// PrintScanStart æ‰“å°æ‰«æå¼€å§‹ä¿¡æ¯
func PrintScanStart(target string) {
	fmt.Println("\n" + strings.Repeat("â•", 70))
	fmt.Println("ðŸš€ Starting Web Cache Poisoning Scan")
	fmt.Println(strings.Repeat("â•", 70))
	fmt.Printf("ðŸŽ¯ Target: %s\n", target)
	fmt.Println(strings.Repeat("â”€", 70))
}

// PrintScanComplete æ‰“å°æ‰«æå®Œæˆä¿¡æ¯
func PrintScanComplete(duration string, vulnCount int) {
	fmt.Println("\n" + strings.Repeat("â•", 70))
	if vulnCount > 0 {
		fmt.Printf("âœ“ Scan complete (%s) - %d vulnerability(ies) found ðŸ”´\n", duration, vulnCount)
	} else {
		fmt.Printf("âœ“ Scan complete (%s) - No vulnerabilities found âœ…\n", duration)
	}
	fmt.Println(strings.Repeat("â•", 70) + "\n")
}

// PrintProgress æ‰“å°è¿›åº¦ä¿¡æ¯
func PrintProgress(step string) {
	fmt.Printf("â³ %s...\n", step)
}

// PrintCacheDetected æ‰“å°ç¼“å­˜æ£€æµ‹ç»“æžœ
func PrintCacheDetected(target, cdn string, keys []string) {
	fmt.Println("\n" + strings.Repeat("â”€", 70))
	fmt.Printf("âœ“ Cache detected: %s\n", cdn)
	if len(keys) > 0 {
		fmt.Printf("  Cache keys: %s\n", strings.Join(keys, ", "))
	}
	fmt.Println(strings.Repeat("â”€", 70))
}

